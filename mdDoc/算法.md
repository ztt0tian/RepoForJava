# 打家劫舍

## 版本1（198）

**背景**：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果**两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额

**实质**：一个非负整数数组，选择若个干非相邻数，使得这些数之和最大

:yin_yang:思路：维护一个dp数组，dp[i]表示前i个房子所能偷到的最高金额；来的第i个房屋前，要么偷要么不偷，即两种情况：

<1>:偷，那么第i-1个屋就不能偷，最终的金额为dp[i-2]+nums[i]

<2>:不偷，最终的金额就与前i-1个房子所能偷到的金额总和即dp[i-1]

故**状态转移方程**为：dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);

初始状态dp[0]=0;dp[1]=nums[i];

```java
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==0) return 0;
        int[] dp=new int[n+1];
        dp[0]=0;
        dp[1]=nums[0];
        for(int i=1;i<n;i++){
            dp[i+1]=Math.max(dp[i-1]+nums[i],dp[i]);
        }
        return dp[n];
    }
}
```

## 版本2（213）

**背景**：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方**所有的房屋都围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

与版本1的区别在于首尾相邻，成环

:yin_yang:思路：在版本1的基础上考虑[1,n-1] [2,n]两个区间上最大值，最多只能偷首尾中的其中一间房

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        return Math.max(solve(nums,0,nums.length-1),solve(nums,1,nums.length));
    }
    public int solve(int[]nums ,int begin,int end){
        int a1=0,a2=0,res=0;
        for(int i=begin;i<end;i++){
            a2=res;
            res=Math.max(res,a1+nums[i]);
            a1=a2;
        }
        return res;
    }
}
```

## ？？？版本3（337）

**背景：**在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个**直接相连的房子在同一天晚上被打劫，房屋将自动报警**。

**实质**：就是房子排列的结构变成二叉树了，且要从根节点出发

