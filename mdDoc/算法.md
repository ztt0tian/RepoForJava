# 打家劫舍

> 版本1

**背景**：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果**两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额

**实质**：一个非负整数数组，选择若个干非相邻数，使得这些数之和最大

:yin_yang:思路：维护一个dp数组，dp[i]表示前i个房子所能偷到的最高金额；来的第i个房屋前，要么偷要么不偷，即两种情况：

<1>:偷，那么第i-1个屋就不能偷，最终的金额为dp[i-2]+nums[i]

<2>:不偷，最终的金额就与前i-1个房子所能偷到的金额总和即dp[i-1]

故**状态转移方程**为：dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);

初始状态dp[0]=0;dp[1]=nums[i];

```
class Solution {
    public int rob(int[] nums) {
        int n=nums.length;
        if(n==0) return 0;
        int[] dp=new int[n+1];
        dp[0]=0;
        dp[1]=nums[0];
        for(int i=1;i<n;i++){
            dp[i+1]=Math.max(dp[i-1]+nums[i],dp[i]);
        }
        return dp[n];
    }
}
```

